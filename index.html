<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Meteorkart over Norge</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />

    <style>
        #map {
            height: 100vh;
        }

        .station-label {
            background-color: white;
            border: 1px solid #333;
            padding: 2px 4px;
            font-size: 12px;
            border-radius: 3px;
        }
    </style>
</head>

<body>

    <div id="map"></div>
    <div
        style="position: absolute; top: 10px; left: 10px; z-index: 1000; background: white; padding: 10px; border-radius: 5px; box-shadow: 0 0 5px rgba(0,0,0,0.3); font-size: 14px;">
        <label>
            Show meteors between:
            <span id="time-start-label">--</span> and <span id="time-end-label">--</span>
        </label>
        <br>
        <input type="range" id="time-start" min="0" max="100" step="1" value="0" style="width: 300px;">
        <input type="range" id="time-end" min="0" max="100" step="1" value="100" style="width: 300px;">
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

    <script>
        const map = L.map('map').setView([59.9, 10.75], 6);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);

        // Set to keep track of already added stations
        const addedStations = new Set();

        let allMeteorData = [];
        let markersAndLines = [];

        fetch('meteors.json')
            .then(response => response.json())
            .then(data => {
                allMeteorData = data;

                // Find min/max observation times
                const allTimes = data.flatMap(event =>
                    event.observations.map(obs => obs.observationStartTime)
                        .filter(time => time > 0)
                );
                const minTime = Math.min(...allTimes);
                const maxTime = Math.max(...allTimes);

                // Store for slider scaling
                const sliderStart = document.getElementById('time-start');
                const sliderEnd = document.getElementById('time-end');
                sliderStart.min = sliderEnd.min = minTime;
                sliderStart.max = sliderEnd.max = maxTime;
                sliderStart.value = minTime;
                sliderEnd.value = maxTime;

                // Update label display
                const labelStart = document.getElementById('time-start-label');
                const labelEnd = document.getElementById('time-end-label');

                function updateLabels() {
                    const startDate = new Date(parseFloat(sliderStart.value) * 1000);
                    const endDate = new Date(parseFloat(sliderEnd.value) * 1000);
                    labelStart.textContent = startDate.toISOString().split('T')[0] + ' ' + startDate.toISOString().split('T')[1].slice(0, 5);
                    labelEnd.textContent = endDate.toISOString().split('T')[0] + ' ' + endDate.toISOString().split('T')[1].slice(0, 5);
                }

                function filterAndRender() {
                    // Clear previous markers/lines
                    markersAndLines.forEach(layer => map.removeLayer(layer));
                    markersAndLines = [];

                    const start = parseFloat(sliderStart.value);
                    const end = parseFloat(sliderEnd.value);

                    allMeteorData.forEach(event => {
                        const observedInRange = event.observations.some(obs =>
                            obs.observationStartTime >= start && obs.observationStartTime <= end
                        );

                        if (!observedInRange) return;

                        const atm = event.atmosphericData;
                        if (atm && atm.startPositionNorth && atm.startPositionEast &&
                            atm.endPositionNorth && atm.endPositionEast) {

                            const startLatLng = [atm.startPositionNorth, atm.startPositionEast];
                            const endLatLng = [atm.endPositionNorth, atm.endPositionEast];

                            // Meteor marker
                            const marker = L.circleMarker(startLatLng, {
                                radius: 4,
                                color: 'darkred',
                                fillColor: 'red',
                                fillOpacity: 0.8
                            }).addTo(map)
                                .bindPopup(`Meteor ID: ${event.id}<br>Start Height: ${atm.startHeight} km`);
                            markersAndLines.push(marker);

                            // Trajectory
                            const line = L.polyline([startLatLng, endLatLng], {
                                color: 'red',
                                weight: 2,
                                opacity: 0.8
                            }).addTo(map);
                            markersAndLines.push(line);
                        }
                    });
                }

                // Initial render
                updateLabels();
                filterAndRender();

                // Handle slider input
                sliderStart.addEventListener('input', () => {
                    if (parseFloat(sliderStart.value) > parseFloat(sliderEnd.value)) {
                        sliderStart.value = sliderEnd.value;
                    }
                    updateLabels();
                    filterAndRender();
                });

                sliderEnd.addEventListener('input', () => {
                    if (parseFloat(sliderEnd.value) < parseFloat(sliderStart.value)) {
                        sliderEnd.value = sliderStart.value;
                    }
                    updateLabels();
                    filterAndRender();
                });
            });
    </script>

    <a href="https://github.com/MortenLohne/meteorkart" target="_blank"
        style="position: absolute; top: 0; right: 0; border: 0; z-index: 1000;">
        <img src="forkme_right_darkblue_121621.png" alt="Fork me on GitHub" style="width: 149px; height: auto;">
    </a>

    <div
        style="position: absolute; bottom: 10px; left: 10px; background: rgba(255,255,255,0.9); padding: 6px 12px; border-radius: 5px; font-size: 16px; box-shadow: 0 0 5px rgba(0,0,0,0.2); z-index: 1000;">
        Dataen er hentet fra <a href="http://norskmeteornettverk.no"> Norsk Meteornettverk</a>, og viser meteorer
        observert i l√∏pet av 2025.
    </div>
</body>

</html>