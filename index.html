<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Meteorkart over Norge</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />

    <style>
        #map {
            height: 100vh;
        }

        .station-label {
            background-color: white;
            border: 1px solid #333;
            padding: 2px 4px;
            font-size: 12px;
            border-radius: 3px;
        }
    </style>
</head>

<!-- noUiSlider CSS -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nouislider@15.7.0/dist/nouislider.min.css">

<!-- noUiSlider JS -->
<script src="https://cdn.jsdelivr.net/npm/nouislider@15.7.0/dist/nouislider.min.js"></script>


<body>

    <div id="map"></div>

    <div
        style="position: absolute; top: 10px; left: 10px; z-index: 1000; background: white; padding: 10px; border-radius: 5px; box-shadow: 0 0 5px rgba(0,0,0,0.3); font-size: 14px; width: 600px;">
        <label>Show meteors between:</label><br>
        <div id="time-slider" style="margin-top: 10px;"></div>
        <div style="margin-top: 6px;">
            <span id="time-start-label">--</span> – <span id="time-end-label">--</span>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

    <script>
        const map = L.map('map').setView([59.9, 10.75], 6);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);

        // Set to keep track of already added stations
        const addedStations = new Set();

        let allMeteorData = [];
        let markersAndLines = [];

        fetch('meteors.json')
            .then(response => response.json())
            .then(data => {
                allMeteorData = data;

                // Find min/max observation times
                const allTimes = data.flatMap(event =>
                    event.observations.map(obs => obs.observationStartTime)
                        .filter(time => time > 0)
                );
                const minTime = Math.min(...allTimes);
                const maxTime = Math.max(...allTimes);

                const slider = document.getElementById('time-slider');
                const labelStart = document.getElementById('time-start-label');
                const labelEnd = document.getElementById('time-end-label');

                // Format Unix timestamp to readable
                function formatTimestamp(ts) {
                    if (typeof ts !== 'number' || isNaN(ts)) return '--';
                    const date = new Date(ts * 1000);
                    if (isNaN(date.getTime())) return '--';
                    return date.toISOString().split('T')[0] + ' ' + date.toISOString().split('T')[1].slice(0, 5);
                }

                const defaultStartTime = new Date("2025-01-01T00:00:00Z").valueOf() / 1000;

                noUiSlider.create(slider, {
                    start: [defaultStartTime, maxTime],
                    connect: true,
                    step: 7 * 24 * 60 * 60, // step by 1 minute
                    range: {
                        min: minTime,
                        max: maxTime
                    },
                    tooltips: [true, true],
                    format: {
                        to: ts => formatTimestamp(ts),
                        from: val => new Date(Number(val))
                    }
                });

                console.log("Created slider");

                // Listen for slider changes and re-render
                slider.noUiSlider.on('update', function (values, handle, unformatted) {
                    const [start, end] = unformatted;
                    labelStart.textContent = formatTimestamp(start);
                    labelEnd.textContent = formatTimestamp(end);
                    filterAndRender(start, end);
                });

                function filterAndRender(startTime, endTime) {
                    markersAndLines.forEach(layer => map.removeLayer(layer));
                    markersAndLines = [];

                    allMeteorData.forEach(event => {
                        const observedInRange = event.observations.some(obs =>
                            obs.observationStartTime >= startTime && obs.observationStartTime <= endTime
                        );

                        if (!observedInRange) return;

                        const atm = event.atmosphericData;
                        if (atm && atm.startPositionNorth && atm.startPositionEast &&
                            atm.endPositionNorth && atm.endPositionEast) {

                            const startLatLng = [atm.startPositionNorth, atm.startPositionEast];
                            const endLatLng = [atm.endPositionNorth, atm.endPositionEast];

                            // Meteor marker
                            const marker = L.circleMarker(startLatLng, {
                                radius: 4,
                                color: 'darkblue',
                                fillColor: 'blue',
                                fillOpacity: 0.8
                            }).addTo(map)
                                .bindPopup(`<a href="http://norskmeteornettverk.no/meteor/${event.id.replace("_", "/")}" target="_blank">ID: ${event.id}</a><br>Slutthøyde: ${atm.endHeight} km<br>Starthøyde: ${atm.startHeight} km`);
                            markersAndLines.push(marker);

                            // Trajectory
                            const line = L.polyline([startLatLng, endLatLng], {
                                color: 'blue',
                                weight: 2,
                                opacity: 0.8
                            }).addTo(map);
                            markersAndLines.push(line);
                        }

                        event.observations.forEach(obs => {
                            const key = `${obs.stationCode}_${obs.stationLatitude}_${obs.stationLongitude}`;
                            if (!addedStations.has(key)) {
                                addedStations.add(key);

                                const stationLatLng = [obs.stationLatitude, obs.stationLongitude];

                                // Circle marker with label
                                L.circleMarker(stationLatLng, {
                                    radius: 8,
                                    color: 'red',
                                    fillColor: '#a00',
                                    fillOpacity: 0.7
                                }).addTo(map)
                                    .bindPopup(`Stasjon: ${obs.stationCode}`);

                                // Optional: add a small label next to each station
                                L.marker(stationLatLng, {
                                    icon: L.divIcon({
                                        className: 'station-label',
                                        html: obs.stationCode,
                                        iconSize: [30, 12],
                                        iconAnchor: [15, -5]
                                    })
                                }).addTo(map);
                            }
                        });
                    });

                }

                // Initial render
                filterAndRender(defaultStartTime, maxTime);
            });
    </script>

    <div
        style="position: absolute; bottom: 10px; left: 10px; background: rgba(255,255,255,0.9); padding: 6px 12px; border-radius: 5px; font-size: 16px; box-shadow: 0 0 5px rgba(0,0,0,0.2); z-index: 1000;">
        Dataen er hentet fra <a href="http://norskmeteornettverk.no"> Norsk Meteornettverk</a>, og viser meteorer
        observert i løpet av 2025.
    </div>
</body>

</html>